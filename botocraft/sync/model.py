from pathlib import Path
from typing import Optional, List, Dict, Any

import botocore.session

from .abstract import AbstractGenerator
from .docstring import DocumentationFormatter
from .shapes import PythonTypeShapeConverter


class PydanticModelGenerator(AbstractGenerator):

    HEADER = """# This file was autogenerated by botocraft.  Do not edit directly.
from typing import Optional, List, Literal

from pydantic import BaseModel

from .abstract import Boto3Model, ReadonlyBoto3Model
"""

    subfolder: str = 'models/base'
    data_file: str = 'models.yml'

    def __init__(self, service_name: str):
        super().__init__(service_name)
        session = botocore.session.get_session()
        #: The botocore service model for our service.
        self.service_model = session.get_service_model(service_name)
        #: We keep track of the classes we've generated so we can add them to
        #: the code in the right order.
        self.classes: Dict[str, str] = {}
        #: The formatter we use to clean up the documentation.
        self.formatter = DocumentationFormatter()
        #: The converter we use to convert botocore shapes to python types.
        self.shape_converter = PythonTypeShapeConverter()

    def get_shape(self, name: str) -> botocore.model.Shape:
        """
        Get a :py:class:`botocore.model.Shape` by name from the service model,
        :py:attr:`service_model`.

        Args:
            name: The name of the shape to retrieve.

        Returns:
            The shape object.
        """
        return (
            self.service_model  # type: ignore  # pylint: disable=protected-access
            ._shape_resolver
            .get_shape_by_name(name)
        )

    def generate(self) -> None:
        """
        Generate the code for the models and write it to the output file.
        """
        for model_name in self.models:
            self.generate_model(model_name, self.get_shape(model_name))
        code = self.HEADER + '\n\n'.join(self.classes.values())
        self.write(code)

    def generate_model(self, model_name: str, shape: botocore.model.Shape) -> None:
        """
        Generate the code for a single model and save it to :py:attr:`classes`.

        Args:
            model_name: The name of the model to generate. This will be the
                name of the class.
            shape: The shape object for the model from the botocore service
                model.
        """
        if model_name in self.classes:
            print(f'Skipping model for {model_name}; already generated')
            return
        else:
            print(f'Generating model for {model_name}')
        model_config: Dict[str, Any] = self.config.get(model_name, {})
        field_configs = model_config.get('fields', {})
        fields: List[str] = []

        if hasattr(shape, 'members'):
            for name, field_shape in shape.members.items():
                field_config = field_configs.get(name, {})
                # Our guess as to the python type for this field
                python_type: Optional[str] = None
                # Whether this field is required
                required: bool = (name in shape.required_members) or field_config.get('required', False)
                # The default value for this field, if any
                default: Optional[str] = field_config.get('default', None)
                if name == 'schedulingStrategy':
                    pass

                try:
                    python_type = self.shape_converter.convert(field_shape)
                except ValueError:
                    if field_shape.type_name == 'list':
                        # This is a list of submodels
                        element_shape = field_shape.member
                        inner_model_name: str = element_shape.name
                        if inner_model_name == 'String' or element_shape.type_name == 'string':
                            inner_model_name = self.shape_converter.convert(element_shape)
                        else:
                            self.generate_model(inner_model_name, element_shape)
                        python_type = f'List[{inner_model_name}]'
                    elif field_shape.type_name == 'structure':
                        # This is a submodel
                        inner_model_name = field_shape.name
                        self.generate_model(inner_model_name, field_shape)
                        python_type = inner_model_name

                if python_type:
                    if not required:
                        python_type = f'Optional[{python_type}]'
                        if default is None:
                            default = 'None'
                    fields.append(self.formatter.format_attribute(field_shape))
                    field_line = f'    {name}: {python_type}'
                    if default:
                        field_line += f' = {default}'
                    fields.append(field_line)

            base_class = 'Boto3Model'
            if model_config.get('readonly', False):
                base_class = 'ReadonlyBoto3Model'

            code: str = f'class {model_name}({base_class}):\n'
            docstring = self.formatter.format_docstring(shape)
            if docstring:
                code += f'    """{docstring}"""\n'
            if fields:
                code += '\n'.join(fields)
            else:
                code += '    pass'
            self.classes[model_name] = code
