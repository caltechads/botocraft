# mypy: disable-error-code="attr-defined"
import warnings
from typing import TYPE_CHECKING, Callable, Dict, List, Optional

import boto3

if TYPE_CHECKING:
    from botocraft.services import ClassicELB


# ----------
# Decorators
# ----------


def add_tags_for_get(func: Callable[..., "ClassicELB"]) -> Callable[..., "ClassicELB"]:
    """
    Wraps :py:meth:`botocraft.services.ecs.ServiceManager.list` to return a list of
    :py:class:`botocraft.services.ecs.Service` objects instead of only a list of
    ARNs.
    """

    def wrapper(self, *args, **kwargs) -> "ClassicELB":
        elb = func(self, *args, **kwargs)
        if elb:
            tags = self.client.describe_tags(LoadBalancerNames=[elb.LoadBalancerName])[
                "TagDescriptions"
            ][0]["Tags"]
            elb.Tags = {tag["Key"]: tag["Value"] for tag in tags}
        return elb

    return wrapper


def add_tags_for_list(
    func: Callable[..., List["ClassicELB"]],
) -> Callable[..., List["ClassicELB"]]:
    """
    Wraps :py:meth:`botocraft.services.ecs.ServiceManager.list` to return a list of
    :py:class:`botocraft.services.ecs.Service` objects instead of only a list of
    ARNs.
    """

    def wrapper(self, *args, **kwargs) -> List["ClassicELB"]:
        elbs = func(self, *args, **kwargs)
        if elbs:
            elb_names = [elb.LoadBalancerName for elb in elbs]
            tag_descriptions = self.client.describe_tags(LoadBalancerNames=elb_names)[
                "TagDescriptions"
            ]
            for elb in elbs:
                for tag in tag_descriptions:
                    if tag["LoadBalancerName"] == elb.LoadBalancerName:
                        elb.Tags = {tag["Key"]: tag["Value"] for tag in tag["Tags"]}
        return elbs

    return wrapper


# ----------
# Decorators
# ----------


class ClassicELBManagerMixin:
    """
    A mixin is used on :py:class:`botocraft.services.elb.ClassicELBManager` to
    implement the "create" method.   Normally we would allow the "create"
    to be automatically generated by the botocraft library, but the Classic ELB
    is fragmented across multiple API calls, so we have to do it here.

    Important:
        Note that there is no "update" method for Classic ELBs.  If you want to
        update a Classic ELB, use the methods on the :py:class:`ClassicELB` object
        itself.

    """

    session: boto3.session.Session

    def create(
        self,
        elb: "ClassicELB",
    ) -> "ClassicELB":
        """
        Create a new :py:class:`ClassicELB` object.  The reason we have to do this
        in a mixin instead of having this as a usual ``.create()`` method automatically
        generated is because Classic ELBs are fragmented across multiple API calls.

        We want to pretend that the Classic ELB is a single object, so we have to
        deal with the fragmentation here.

        Args:
            elb: The :py:class:`ClassicELB` object to create

        Keyword Args:
            Tags: A dictionary of tags to apply to the ELB

        Returns:
            The newly created :py:class:`ClassicELB` object

        """
        tags: Optional[List[Dict[str, str]]] = None
        if elb.Tags:
            tags = [{"Key": key, "Value": value} for key, value in elb.Tags.items()]
        self.client.create_load_balancer(
            LoadBalancerName=elb.LoadBalancerName,
            Listeners=self.serialize(
                [listener.Listeners for listener in elb.Listeners]
            ),
            AvailabilityZones=elb.AvailabilityZones,
            Subnets=elb.Subnets,
            SecurityGroups=elb.SecurityGroups,
            Scheme=elb.Scheme,
            Tags=tags,
        )

        if elb.HealthCheck:
            self.client.configure_health_check(
                LoadBalancerName=elb.LoadBalancerName,
                HealthCheck=self.serialize(elb.HealthCheck),
            )

        if elb.Policies:
            if elb.Policies:
                if elb.Policies.AppCookieStickinessPolicies:
                    self.client.create_app_cookie_stickiness_policy(
                        LoadBalancerName=elb.LoadBalancerName,
                        PolicyName=elb.Policies.AppCookieStickinessPolicies[
                            0
                        ].PolicyName,
                        CookieName=elb.Policies.AppCookieStickinessPolicies[
                            0
                        ].CookieName,
                    )
                if elb.Policies.LBCookieStickinessPolicies:
                    self.client.create_lb_cookie_stickiness_policy(
                        LoadBalancerName=elb.LoadBalancerName,
                        PolicyName=elb.Policies.LBCookieStickinessPolicies[
                            0
                        ].PolicyName,
                        CookieExpirationPeriod=elb.Policies.LBCookieStickinessPolicies[
                            0
                        ].CookieExpirationPeriod,
                    )
                if elb.Policies.OtherPolicies:
                    names = ", ".join(elb.Policies.OtherPolicies)
                    # Warn that these policies must be created via
                    # ClassicELB.create_policy
                    warnings.warn(
                        f"ClassicELB(LoadBalancerName='{elb.LoadBalancerName}'): "
                        "These polices must be created via ClassicELB.create_policy: "
                        f"{names}",
                        UserWarning,
                        stacklevel=2,
                    )
        return self.objects.using(self.session).get(elb.LoadBalancerName)
